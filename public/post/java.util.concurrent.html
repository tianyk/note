<!DOCTYPE html>
<html lang=zh>
<!-- zh-cmn-Hans -->
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="360-site-verification" content="8902ef2b161a9e0f358117b6fe156521" />
    
    <meta name="description" content="并发编程多线程在多核心机器中能减少资源浪费，充分利用多核性能。在单核心机器中能提高吞吐率。 可见性和指令重排是编发编程中出现问题的原因所在。Java内存模型分为主内存和工作内存两部分。JMM规定，线程写值时只能写到工作内存，不能直接写到主内存。JVM定期（内存屏障）将工作内存的值刷会主内存。同样，读取共享变量的值时只能从工作内存中读取，工作内存不能直接读取主内存。 123456789101112">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发">
<meta property="og:url" content="https://kekek.cc/post/java.util.concurrent.html">
<meta property="og:site_name" content="Keke的个人网站">
<meta property="og:description" content="并发编程多线程在多核心机器中能减少资源浪费，充分利用多核性能。在单核心机器中能提高吞吐率。 可见性和指令重排是编发编程中出现问题的原因所在。Java内存模型分为主内存和工作内存两部分。JMM规定，线程写值时只能写到工作内存，不能直接写到主内存。JVM定期（内存屏障）将工作内存的值刷会主内存。同样，读取共享变量的值时只能从工作内存中读取，工作内存不能直接读取主内存。 123456789101112">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kekek.cc/images/thread-state.jpg">
<meta property="og:image" content="https://kekek.cc/images/FutureTask.png">
<meta property="og:image" content="https://kekek.cc/images/future.png">
<meta property="og:image" content="https://kekek.cc/images/amdahl.png">
<meta property="article:published_time" content="2018-01-08T04:51:13.000Z">
<meta property="article:modified_time" content="2018-08-20T10:36:33.000Z">
<meta property="article:author" content="tyk">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kekek.cc/images/thread-state.jpg">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Java并发</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="Keke的个人网站" type="application/atom+xml" />
    
<meta name="generator" content="Hexo 8.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/search/">搜索</a></li>
         
          <li><a href="/atom.xml">RSS</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/post/dns.html"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/post/sock5.html"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="mailto:?subject=Java并发&body=Check out this article: https://kekek.cc/post/java.util.concurrent.html"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://kekek.cc/post/java.util.concurrent.html&title=Java并发"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">1.1.</span> <span class="toc-text">内存屏障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E4%B8%8Evolatile"><span class="toc-number">1.2.</span> <span class="toc-text">synchronized与volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">1.3.</span> <span class="toc-text">并发与同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.</span> <span class="toc-text">并发编程中的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.5.1.</span> <span class="toc-text">线程状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD"><span class="toc-number">1.5.2.</span> <span class="toc-text">线程中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%B8%AD%E6%96%AD%E4%BB%BB%E5%8A%A1%EF%BC%9F"><span class="toc-number">1.5.3.</span> <span class="toc-text">如何中断任务？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shutdown-Hook"><span class="toc-number">1.5.4.</span> <span class="toc-text">Shutdown Hook</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97"><span class="toc-number">1.5.5.</span> <span class="toc-text">内置条件队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7"><span class="toc-number">1.6.</span> <span class="toc-text">同步工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">同步容器 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">并发容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">1.6.3.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.6.4.</span> <span class="toc-text">同步工具类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">1.7.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F"><span class="toc-number">1.7.1.</span> <span class="toc-text">原子变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.8.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5"><span class="toc-number">1.8.1.</span> <span class="toc-text">饱和策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%81%9C%E6%AD%A2"><span class="toc-number">1.8.2.</span> <span class="toc-text">线程池停止</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Amdahl%E5%AE%9A%E5%BE%8B"><span class="toc-number">1.9.</span> <span class="toc-text">Amdahl定律</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="toc-number">1.10.</span> <span class="toc-text">常见异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.11.</span> <span class="toc-text">参考</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Java并发
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">tyk</span>
      </span>
      
    <div class="postdate">
        <time datetime="2018-01-08T04:51:13.000Z" itemprop="datePublished">2018-01-08</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>多线程在多核心机器中能减少资源浪费，充分利用多核性能。在单核心机器中能提高吞吐率。</p>
<p><code>可见性</code>和<code>指令重排</code>是编发编程中出现问题的原因所在。Java内存模型分为<code>主内存</code>和<code>工作内存</code>两部分。JMM规定，线程写值时只能写到<code>工作内存</code>，不能直接写到<code>主内存</code>。JVM定期（内存屏障）将<code>工作内存</code>的值刷会主内存。同样，读取<code>共享变量</code>的值时只能从<code>工作内存</code>中读取，<code>工作内存</code>不能直接读取<code>主内存</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoViisibility</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> ready;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!ready) Thread.<span class="keyword">yield</span>();</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 由于指令重排，下面三行代码可能会以任意顺序执行。指令重排的前提是不会影响逻辑正确性。</span></span><br><span class="line"><span class="comment">         * 由于内存屏蔽，修改number、ready的值后子线程不一定能获取到最新的值。</span></span><br><span class="line"><span class="comment">         * 可能出现的结果：</span></span><br><span class="line"><span class="comment">         * 1. 由于读取不到number的值可能一直循环下去 （由于指令重排，此时的值可能是42也可能是0）</span></span><br><span class="line"><span class="comment">         * 2. 读取到了number输出是0</span></span><br><span class="line"><span class="comment">         * 3. 输出42</span></span><br><span class="line"><span class="comment">         * 注意：单线程环境下指令重排也会有，因为每次读取的都是线程内缓存所以不会出现读不到最新值的情况。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ReaderThread</span>().start();</span><br><span class="line">        number = <span class="number">42</span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>Java有<code>工作内存</code>和<code>主内存</code>，工作内存要定期将内容刷回主内存才能保证可见。那什么时候刷回去呢？在Java里面遇到内存屏障指令时就会将工作内存和主内存进行同步。例如，我们使用<code>synchronized</code>可以保证可见性，这是因为在<code>synchronized</code>代码块的第一行和最后一行会插入内存屏障，进入<code>synchronized</code>代码块时会从主内存获取一遍变量，退出<code>synchronized</code>代码块时会将工作内存刷回主存。</p>
<h3 id="synchronized与volatile"><a href="#synchronized与volatile" class="headerlink" title="synchronized与volatile"></a>synchronized与volatile</h3><p><code>synchronized</code>能保证可见性和原子性，<code>volatile</code>只能保证可见性。看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例不是并发安全的。虽然我们能看到<code>count</code>的新值，但是<code>count++</code>是一个符合操作。要将<code>incr</code>变为原子操作只能使用<code>synchronized</code>关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>volatile</code>一般应用在标志位变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Loop</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> shutdown;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!shutdown) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        shutdown = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并发与同步"><a href="#并发与同步" class="headerlink" title="并发与同步"></a>并发与同步</h3><p>并发程序可以并行执行任务也可以串行来执行。并发是去同时应对多个任务，并行是同时去做多种任务。</p>
<p>并发在同时应对多种任务时，需要去处理同步的问题。</p>
<h3 id="并发编程中的问题"><a href="#并发编程中的问题" class="headerlink" title="并发编程中的问题"></a>并发编程中的问题</h3><ul>
<li><p>死锁</p>
<p>  根本原因是要获取多把锁，但是不同线程<strong>加锁顺序不同</strong>。</p>
</li>
<li><p>饥饿</p>
<p>  一直等待某种状态。</p>
</li>
<li><p>活锁</p>
<p>  是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源。线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。</p>
</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li><p>start </p>
<p>  启动一个线程。</p>
</li>
<li><p>run </p>
<p>  直接在当前线程内运行。可用于线程封装，比如线程池内运行线程可以直接在线程池线程中调用被传入线程的<code>run</code>方法。</p>
</li>
<li><p>sleep</p>
<p>  线程休眠，会释放CPU资源但是不会释放锁。</p>
</li>
<li><p>yield </p>
<p>  短暂让出CPU资源，不像sleep时间结束后进入<code>RUNNABLE</code>状态，它会立即进入<code>RUNNABLE</code>状态等待CPU资源。它同样不会释放锁。</p>
</li>
<li><p>join </p>
<p>  用于线程协调。调用<code>t.join()</code>当前线程会等待线程<code>t</code>执行完再继续执行。</p>
</li>
<li><p>interrupt</p>
<p>  中断，类似一种信号，是一种协商机制。具体查看下面的中断机制。</p>
</li>
<li><p>wait、notify&#x2F;notifyAll </p>
<p>  这两者属于Object类上的方法，用于线程<em>通讯</em>（其实没有讯息，类似一个通知机制）。具体查看下面的内置条件队列。</p>
</li>
</ul>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p><img src="/images/thread-state.jpg"></p>
<h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><p><code>interrupted</code>是一种协商机制，中断机制是一种协作机制，也就是说通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理中断。可以理解为进程通信中的信号，例如<code>kill -n pid</code>。<code>interrupt</code>信号是通知线程应该中断了，具体到底中断还是继续运行，应该由被通知的线程自己处理。</p>
<ul>
<li><p>public void interrupt()</p>
<ul>
<li><p>将调用者线程的中断状态设为true。</p>
</li>
<li><p>被通知中断的线程在阻塞时，会抛出<code>InterruptedException</code>异常，同时<strong>将中断状态修改为false</strong>。</p>
<p>  如果线程被中断<code>interrupt()</code>后，我们并不想立即中断它那么我们需要重置中断状态为<code>未中断</code>。不然很多依赖中断状态<code>isInterrupted()</code>的方法会出问题。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ... </span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">    <span class="comment">// 重置中断状态为 true</span></span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>public boolean isInterrupted() </p>
<ul>
<li>判断调用者线程的中断状态。</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>public static boolean interrupted()</p>
<ul>
<li>返回当前线程的中断状态</li>
<li>将当前线程的中断状态设为false</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Tests if some Thread has been interrupted.  The interrupted state</span></span><br><span class="line"><span class="comment">* is reset or not based on the value of ClearInterrupted that is</span></span><br><span class="line"><span class="comment">* passed.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> ClearInterrupted 是否清除中断状态</span></span><br><span class="line"><span class="comment">* 清除中断状态</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interrupted</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//中断后结束循环</span></span><br><span class="line">            <span class="comment">//while (!Thread.currentThread().isInterrupted()) &#123;</span></span><br><span class="line">            <span class="comment">//    System.out.println(&quot;.&quot;);</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果线程被中断后，我们并不想立即中断它那么我们需要重置中断状态为`未中断`。</span></span><br><span class="line">            <span class="comment">// 不然很多依赖中断状态的方法会出错，例如后面的sleep。</span></span><br><span class="line">            <span class="comment">// 重置中断状态，置线程状态为未中断。</span></span><br><span class="line">            <span class="comment">// Thread.interrupted();</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">// 阻塞的线程被中断后，会抛出InterruptedException异常。并且中断状态会重置为未中断</span></span><br><span class="line">                <span class="comment">// 很多时候我们为了中断保证状态的正确，需要在捕获异常后将状态重置为已中断</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 恢复中断(状态) 置线程状态为中断</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;catch1: %b\n&quot;</span>, Thread.currentThread().isInterrupted());</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                System.out.printf(<span class="string">&quot;catch2: %b\n&quot;</span>, Thread.currentThread().isInterrupted());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">// Thread.sleep(4);</span></span><br><span class="line">        <span class="comment">// 中断线程</span></span><br><span class="line">        t.interrupt();</span><br><span class="line">    </span><br><span class="line">        System.out.printf(<span class="string">&quot;outer1: %b\n&quot;</span>, t.isInterrupted());</span><br><span class="line">        System.out.printf(<span class="string">&quot;outer2: %b\n&quot;</span>, t.isInterrupted());</span><br><span class="line">        System.out.printf(<span class="string">&quot;outer3: %b\n&quot;</span>, t.isInterrupted());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个线程，打印顺序每次可能不同</span></span><br><span class="line">        <span class="comment">// out &gt;&gt;</span></span><br><span class="line">        <span class="comment">//outer1: true   // 刚被中断，状态变为已中断</span></span><br><span class="line">        <span class="comment">//outer2: false  // 中断被catch后状态变为未中断</span></span><br><span class="line">        <span class="comment">//outer3: false  // 已中断</span></span><br><span class="line">        <span class="comment">//catch1: false  // 捕获异常后，状态为未中断</span></span><br><span class="line">        <span class="comment">//catch2: true   // 捕获异常后，重置中断状态后</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//out &gt;&gt;</span></span><br><span class="line">        <span class="comment">//outer1: true   // 刚被中断，状态变为已中断</span></span><br><span class="line">        <span class="comment">//catch1: false  // 捕获异常后，状态为未中断</span></span><br><span class="line">        <span class="comment">//outer2: false  // 中断被catch后状态变为未中断</span></span><br><span class="line">        <span class="comment">//catch2: true   // 捕获异常后，重置中断状态后</span></span><br><span class="line">        <span class="comment">//outer3: true   // catch里面重置状态中断状态后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何中断任务？"><a href="#如何中断任务？" class="headerlink" title="如何中断任务？"></a>如何中断任务？</h4><p>可中断任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">    <span class="comment">// 恢复中断状态</span></span><br><span class="line">    Thread.currentThread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不可中断非阻塞任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不可中断阻塞任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SocketThread</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理中断</span></span><br><span class="line"><span class="comment">     * 关闭socket触发IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ignore) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ReadableByteChannel</span> <span class="variable">channel</span> <span class="operator">=</span> Channels.newChannel(socket.getInputStream())) &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span> * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里会阻塞</span></span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != channel.read(buffer)) &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="comment">// write</span></span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">            <span class="comment">// socket.close() 触发 IOException 线程退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Shutdown-Hook"><a href="#Shutdown-Hook" class="headerlink" title="Shutdown Hook"></a>Shutdown Hook</h4><p>JVM在退出前会首先调用所有注册的关闭钩子。JVM不保证调用顺序（可以注册多个钩子），钩子必须是线程安全的。我们在钩子里面可以做清理工作。钩子应当尽快退出，它会延迟JVM结束时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 清理工作</span></span><br><span class="line">    System.out.println(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h4 id="内置条件队列"><a href="#内置条件队列" class="headerlink" title="内置条件队列"></a>内置条件队列</h4><p>这里的条件是一种<strong>状态</strong>，当达到某种状态后我们可以继续后面的操作。例如，<code>队列空</code>、<code>队列满</code>都是一种状态，当队列为空时我们不能<code>take</code>操作，当队列满时我们不能<code>push</code>操作。当遇到上述状态时，我们可以可能需要等待，等待状态变更我们能进一步执行。等待的方式有多种，我们可以<code>自旋</code>也可以<code>休眠</code>。如果等待时间过久，<code>自旋</code>会浪费大量的CPU资源。如果<code>休眠</code>我们系统将不够灵敏。如果能有一种<code>通知机制</code>，当状态变更时通知我们的线程醒来再次检查状态。</p>
<p>Java里面wait&#x2F;notify就是这种机制。当我们在一个把锁上<code>wait</code>时，线程将<strong>释放锁</strong>并且CPU资源处于休眠状态。当在一把锁上调用<code>notify/notifyAll</code>时将唤醒在同一把锁上等待的线程。这既避免了<code>自旋</code>过久对于CPU的浪费，也解决了<code>休眠</code>时不能立即唤醒的问题。</p>
<p>我们可以看做每一把锁上面都有一个队列，队列里面存放的是这把锁上<code>wait</code>的线程，当在这把锁上调用<code>notify/notifyAll</code>时会唤醒队列里面的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Queue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Queue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Queue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.size() &gt;= capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> take(Long.MAX_VALUE); <span class="comment">// 默认最大值，避免wait无意义的自动唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T <span class="title function_">take</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 锁一个私有的对象用来封闭条件队列</span></span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isEmpty()) list.wait(timeout);</span><br><span class="line"></span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> list.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 注意：此处必须是notifyAll，因为在list这把锁上除了等待`isEmpty`条件还有等待`isFull`条件等待的线程</span></span><br><span class="line">            <span class="comment">// 如果仅仅是notify将会只唤醒一个线程，我们本意是想唤醒`isFull`条件省等待的线程。如果唤醒的恰恰又是`isEmpty`条件上等待的线程，</span></span><br><span class="line">            <span class="comment">// 那么将会出现虽然`isFull`条件已经满足，但是在上述条件上等待的线程将不能被唤醒。</span></span><br><span class="line">            <span class="comment">// 要解决上述问题现在只有用notifyAll唤醒所有等待线程（惊群效应），让它们重新检查条件。如果符合则向下执行，如果不符合继续休眠。</span></span><br><span class="line">            <span class="comment">// 要完美解决上述问题需要后面的`Condition`条件队列支持。</span></span><br><span class="line">            list.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        push(t, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T t, <span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isFull()) list.wait(timeout);</span><br><span class="line"></span><br><span class="line">            list.add(t);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自Java 1.5开始，Java并发包提供了新的选择，我们可以使用<code>Condition</code>来实现条件队列。它与传统的不同之处在于，在同一把锁上，我们可以创建多个条件队列，不同的条件可以放到不同的队列中。上例中有个弊端，当我们<code>notifyAll</code>时<code>isEmpty</code>和<code>isFull</code>条件等待的线程都会被唤醒。另外一个弊端是所有线程都会被唤醒，但是不是所有的线程获取锁再继续执行时就能满足条件，有可能会再次进入等待。例如对于生产者消费者模型，有多个消费者等待而此时只有一个生产者只生产了一个，那么所有消费者都被唤醒时，只有一个会成功抢到任务。其它会在唤醒后再次等待。还有一种情况是由于所有条件都在一个队列中，这个队列中可能既<code>队列空</code>又有<code>队列满</code>两种等待条件。我们一个<code>notifyAll</code>会唤醒两者，而实际情况是我们只想唤醒一种条件。例如，<code>push</code>时只想唤醒<code>队列空</code>条件的等待，而<code>take</code>时只想唤醒<code>队列满</code>条件的等待。这种无差别的唤醒同样会造成一种浪费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Queue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 为队列满和队列空分别创建条件队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">isFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">isEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Queue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Queue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.size() &gt;= capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> take(Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T <span class="title function_">take</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isEmpty()) isEmpty.await(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> list.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 不同等待条件分队列后就不需要全部唤醒（signalAll）了</span></span><br><span class="line">            <span class="comment">// 以前我们不能使用的原因两种条件等待都在一个队列里，由于我们不能控制唤醒谁就可能会唤醒一个我们不想唤醒的等待。</span></span><br><span class="line">            <span class="comment">// 例如我们在take后push操作上的等待应该可以执行了，由于无差别的唤醒可能我们会又唤醒一个take操作上的等待。</span></span><br><span class="line">            isFull.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        push(t, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T t, <span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isFull()) isFull.await(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">            list.add(t);</span><br><span class="line">            isEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步工具"><a href="#同步工具" class="headerlink" title="同步工具"></a>同步工具</h3><h4 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器 "></a>同步容器 </h4><ul>
<li><p>Vector</p>
<p>  最初版本的同步集合，所有方法均使用synchronized加锁同步。</p>
</li>
<li><p>HashTable </p>
<p>  最初版本的同步哈希表，所有方法均加锁同步。</p>
</li>
<li><p>Collections.synchronized(Collection|List|Map|Set|SortMap|SortSet)</p>
<p>  以上同步容器使用装饰器模式实现，将一个线程不安全的List&#x2F;Map封闭在容器内部，通过同一把锁（同步容器本身）保护对对象的所有操作（和Vector类似）。这种方式最重要的一点是防止被封闭的对象逸出。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SynchronizedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">SynchronizedCollection</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">7754090372962971524L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> List&lt;E&gt; list;</span><br><span class="line"></span><br><span class="line">    SynchronizedList(List&lt;E&gt; list) &#123;</span><br><span class="line">        <span class="built_in">super</span>(list);</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    SynchronizedList(List&lt;E&gt; list, Object mutex) &#123;</span><br><span class="line">        <span class="built_in">super</span>(list, mutex);</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 所有操作上都使用锁同步</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.get(index);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.set(index, element);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;list.add(index, element);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.remove(index);&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h4><ul>
<li><p>CopyOnWriteArrayList</p>
<p>  写入时复制的思想，每次更新时都会重新copy一份新的数据。由于每次修改都会复制底层数组，当容器规模较大时将会产生较大的开销。对于容器修改尽量调用批量操作的API，减少容器数据复制操作。这种容器主要用在读多写少的场景中。</p>
<p>  多线程可以同时对容器进行迭代，不会彼此干扰或与修改容器的线程相互干扰。写入时复制不会抛出<code>ConcurrentModificationException</code>异常，迭代的是创建迭代器时的元素，修改操作不会对迭代的数据有影响（修改后被迭代的数组和容器此时的数组已经不是同一个了，因此也不可能读到最新容器的变化）。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CopyOnWriteArrayList.add </span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 排它锁保证了并发的安全性(可见性/原子性)，所有的更新操作使用同一把锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 容器底层数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="comment">// !!!重点</span></span><br><span class="line">        <span class="comment">// 复制原数组到新数组中</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将元素添加到新数组中</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 重置容器底层数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历操作</span></span><br><span class="line"><span class="comment">// 遍历的是创建迭代器时的数组，后面再修改已经不是修改的此数组了。</span></span><br><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">COWIterator</span>&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ConcurrentHashMap</p>
<p>  <code>ConcurrentHashMap</code>使用<code>锁分段</code>的思想，将原来的一个锁应用在整个容器上拆分为多个锁每个锁锁定容器一部分数据的形式。这能减少锁竞争，提高程序的可伸缩性。</p>
</li>
</ul>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>Queue、Deque</p>
<table>
<thead>
<tr>
<th>-</th>
<th>-</th>
<th>-</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td>增加一个元索</td>
<td>如果队列已满，则抛出一个IIIegaISlabEepeplian异常</td>
</tr>
<tr>
<td>remove</td>
<td>移除并返回队列头部的元素</td>
<td>如果队列为空，则抛出一个NoSuchElementException异常</td>
</tr>
<tr>
<td>element</td>
<td>返回队列头部的元素</td>
<td>如果队列为空，则抛出一个NoSuchElementException异常</td>
</tr>
<tr>
<td>offer</td>
<td>添加一个元素并返回true</td>
<td>如果队列已满，则返回false</td>
</tr>
<tr>
<td>poll</td>
<td>移除并返问队列头部的元素</td>
<td>如果队列为空，则返回null</td>
</tr>
<tr>
<td>peek</td>
<td>返回队列头部的元素</td>
<td>如果队列为空，则返回null</td>
</tr>
<tr>
<td>put</td>
<td>添加一个元素</td>
<td>如果队列满，则阻塞</td>
</tr>
<tr>
<td>take</td>
<td>移除并返回队列头部的元素</td>
<td>如果队列为空，则阻塞</td>
</tr>
</tbody></table>
<ul>
<li><p>LinkedBlockingQueue</p>
<p>  底层有链表实现。</p>
</li>
<li><p>ArrayBlockingQueue</p>
<p>  底层有数组实现。</p>
</li>
<li><p>DelayQueue</p>
<p>  延迟队列，只有延迟期满时才能从中提取元素。</p>
</li>
<li><p>SynchronousQueue </p>
<p>  <code>SynchronousQueue</code>并不是一个真正的队列，它没有存储功能，不缓存元素。它维护的是是一组工作线程，任务直接从生产者到消费者手中，中间没有延迟。<code>newCachedThreadPool</code>使用的正是这种队列。</p>
</li>
</ul>
<h4 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h4><ul>
<li><p>CountDownLatch</p>
<ul>
<li>确保某个计算在其需要的所有资源都被初始化之后才继续执行。</li>
<li>确保某个服务在其所依赖的其它所有服务都启动后才启动。</li>
<li>等待知道某个动作的所有参与者都就绪再继续执行。</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 模拟田径比赛</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Track</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 发令枪</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">startingGun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// runner code</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// runner</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                System.out.printf(<span class="string">&quot;Runner-%d 准备好了\n&quot;</span>, number);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    startingGun.await(); <span class="comment">// 所有线程到这里开始等待一起执行</span></span><br><span class="line">                    start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 随机跑步时间</span></span><br><span class="line">                    Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123; &#125;</span><br><span class="line"></span><br><span class="line">                System.out.printf(<span class="string">&quot;Runner-%d 用时：%d ms\n&quot;</span>, number, System.currentTimeMillis() - start);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        startingGun.countDown(); <span class="comment">// startingGun </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>FutureTask    </p>
<p>  多个耗时的任务可以异步执行，通过<code>get</code>拿到执行后的结果。任务只会执行一次，最终状态不会改变（类似Promise）。</p>
<p>  <img src="/images/FutureTask.png"><br>  <img src="/images/future.png"></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        Callable&lt;Integer&gt; callable = () -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟计算耗时</span></span><br><span class="line">            Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">            <span class="comment">// 返回结果</span></span><br><span class="line">            <span class="keyword">return</span> random.nextInt(<span class="number">10</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Integer&gt; queryOne = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">        FutureTask&lt;Integer&gt; queryTwo = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(queryOne).start();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(queryTwo).start();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 未执行完的情况下，get时会阻塞。</span></span><br><span class="line">            <span class="comment">// 最终执行时间取决于执行时间最长的任务。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">revOne</span> <span class="operator">=</span> queryOne.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">revTwo</span> <span class="operator">=</span> queryTwo.get();</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d + %d = %d\n&quot;</span>, revOne, revTwo, revOne + revTwo);</span><br><span class="line">            System.out.println(queryOne.get() + queryTwo.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">            <span class="comment">// e.printStackTrace();</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> e.getCause();</span><br><span class="line">            <span class="comment">//if (cause instanceof ) &#123;</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">//&#125; else &#123;</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Semaphore    </p>
<p>  Semaphore中管理者一组虚拟的许可证，许可证的数量通过构造函数指定。获得操作前只有获得许可证后才能继续执行，执行结束后释放许可证。常用于连接池等类似的场景。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟银行窗口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankWindow</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="comment">// 共六个窗口工作</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">window</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 共20个顾客在排队办理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;顾客%d等待中..\n&quot;</span>, number);</span><br><span class="line">                    window.acquire(); <span class="comment">// 获得一个牌</span></span><br><span class="line">                    System.out.printf(<span class="string">&quot;开始为顾客%d办理业务\n&quot;</span>, number);</span><br><span class="line">                    Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">                    System.out.printf(<span class="string">&quot;顾客%d办理完成\n&quot;</span>, number);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    window.release(); <span class="comment">// 归还牌 </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Barrier </p>
<p>  同<code>CountDownLatch</code>不同的地方是<code>CyclicBarrier</code>是先干后集合，而<code>CountDownLatch</code>一般是先集合后开始干。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟银行金库。</span></span><br><span class="line"><span class="comment">// 金库大门共三把锁，分别有三个经理拿着钥匙。</span></span><br><span class="line"><span class="comment">// 只有三个经理人都开锁时，金库大门才会开。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankVault</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">lockNumber</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 保险库大门有三把锁</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">bankVaultDoor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(lockNumber, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;金库已开&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lockNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 经理人</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;经理%d开始开锁\n&quot;</span>, number);</span><br><span class="line">                    <span class="comment">// 模拟每个经理人的开锁时间</span></span><br><span class="line">                    Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">                    System.out.printf(<span class="string">&quot;经理%d开始开锁完成\n&quot;</span>, number);</span><br><span class="line">                    <span class="comment">// 开锁</span></span><br><span class="line">                    bankVaultDoor.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    <span class="comment">//await中断</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ForkJoin</p>
<p>  ForkJoin采用分治算法，将大任务拆分成小任务来处理。通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，Fork&#x2F;Join框架提供了以下两个子类：</p>
<ul>
<li>RecursiveAction：用于没有返回结果的任务。</li>
<li>RecursiveTask ：用于有返回结果的任务。</li>
</ul>
<p>  常用模式（分治）：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Result <span class="title function_">solve</span><span class="params">(Problem problem)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (problem is small) &#123;</span><br><span class="line">        <span class="comment">// 直接解决</span></span><br><span class="line">        directly solve problem</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 拆分问题</span></span><br><span class="line">        split problem into independent parts</span><br><span class="line">        fork <span class="keyword">new</span> <span class="title class_">subtasks</span> to solve each part</span><br><span class="line">        join all subtasks</span><br><span class="line">        compose result from subresults</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  Fork&#x2F;Join求和<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinSum</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> low;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForkJoinSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForkJoinSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.low = low;</span><br><span class="line">        <span class="built_in">this</span>.high = high;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 小任务直接处理</span></span><br><span class="line">        <span class="keyword">if</span> (high - low &lt; THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.stream(Arrays.copyOfRange(nums, low, high)).asLongStream().sum();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 大人物先拆分再合并结果</span></span><br><span class="line">            <span class="type">ForkJoinSum</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinSum</span>(nums, low, low + (high - low) / <span class="number">2</span>);</span><br><span class="line">            <span class="type">ForkJoinSum</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinSum</span>(nums, low + (high - low) / <span class="number">2</span>, high);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意：不要两个线程都fork，不然当前线程将无任务可做。</span></span><br><span class="line">            <span class="comment">// invokeAll其中left会在当前线程内执行，right会fork在线程池中另一个线程中执行。</span></span><br><span class="line">            invokeAll(left, right);</span><br><span class="line">            <span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[count];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) nums[i] = random.nextInt(count);</span><br><span class="line"></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>); <span class="comment">// 最大并发数4</span></span><br><span class="line">        <span class="type">ForkJoinSum</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinSum</span>(nums);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">ret</span> <span class="operator">=</span> pool.invoke(task);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul>
<li><p>内置锁 </p>
<p>  内置锁能同时保证<code>原子性</code>和<code>可见性</code>。内置锁是独占锁，会增加串行代码比例，降低程序的可伸缩性。</p>
<p>  内置锁是一种可重入锁，如果已经获得了锁，后面在遇到相同的锁时可以直接进入。</p>
<p>  是用不用的锁组合时一定要注意加锁的顺序，避免交叉造成死锁的问题。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锁为实例(this)对象 </span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特定的锁对象，可以将锁对象封闭在程序内部。</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锁为class对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ReentrantLock </p>
<p>  <code>ReentrantLock</code>提供了和<code>synchronized</code>一样的互斥性及内存可见性。在大多数场景下使用<code>synchronized</code>就够了，但是内置锁有一些局限性。例如，我们无法中断一个等待获取锁的线程。但是使用<code>ReentrantLock</code>也有缺点，我们必须手动释放锁。<code>ReentrantLock</code>和内置锁性能相当，仅当内置锁不能满足需求时才考虑使用<code>ReentrantLock</code>。就性能而言，我们也应当首选内置锁，因为内置锁的JVM的内置属性，它能执行一些优化。</p>
<p>  <code>ReentrantLock</code>可以提供公平锁，线程按照它们发出请求的顺序来获得锁。非公平锁允许<code>插队</code>行为，当请求一把非公平锁时，如果在发出请求时同时改锁状态变为可用，那么这个线程将跳过所有等待线程而获得这个锁。由于公平锁所有线程在等待锁时都要排队，这将会增加线程切换降低性能，而<code>插队</code>将减少一次上下文切换。当持有锁的时间较长时，应该使用公平锁。</p>
<p>  <code>ReentrantLock</code>实现了<code>Lock</code>接口。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得一把锁</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得一把锁，锁获取时可以中断</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一把锁，获得返回true</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获得一把锁，等待一定的时间（获取锁时可中断）。获得返回true</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 条件队列</span></span><br><span class="line">    Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  组合运用</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentIncrease</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ++total;</span><br><span class="line">            <span class="comment">// 内部输出后会发生IO阻塞，会放弃CPU资源</span></span><br><span class="line">            <span class="comment">// System.out.printf(&quot;total: %d\n&quot;, total);</span></span><br><span class="line">            <span class="keyword">return</span> total;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ConcurrentIncrease</span> <span class="variable">increase</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcurrentIncrease</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">start</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(count);</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">done</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(count, () -&gt; &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;total: %d\n&quot;</span>, increase.total);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    start.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123; &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(increase.incr());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    done.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException ignored) &#123; &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            start.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ReadWriteLock </p>
<p>  <code>ReentrantLock</code>和内置锁都是互斥锁，每次只能有一个线程持有锁。互斥锁是一种保守的加锁策略，它可以避免<code>写\写</code>和<code>读\写</code>的冲突，但它同时也限制了<code>读\读</code>。读写锁正是来解决这一问题的，只要能保证每个线程都能读到最新的数据，并且读数据时不会有其它线程来修改数据，那就不会发生问题。使用了读写锁后，一个资源可以同时被多个读操作或者一个写操作，但二者不能同时进行。</p>
<p>  读写锁实现方式</p>
<ul>
<li><strong>释放优先</strong>。当写入线程释放写锁时，如果正在排队的同时存在读和写线程，改优先选择读线程还是写线程。</li>
<li><strong>读线程插队</strong>。如果锁有读线程获取，但是有写线程等待，那么新到的读线程是否能立即获得锁，还是排队在写线程后面。</li>
<li><strong>重入性</strong>。读取锁和写入锁是否可重入。</li>
<li><strong>降级</strong>。如果一个线程持有写入锁，它是否能再不释放该锁的情况下获取读锁。这个线程将同时拥有读写锁，同时将阻止其它线程对被保护资源的读写。</li>
<li><strong>升级</strong>。读锁能否由于其它正在等待的读线程和写线程升级为一个写入锁。（这协商不好将发生死锁的情况，如果两个读锁同时要升级为写锁）。</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteMap</span> &lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">r</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">w</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReadWriteMap</span><span class="params">(Map&lt;K, V&gt; map)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">// remove/putAll/clear/size/isEmpty/containsKey/containsValue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h4><p>在<code>java.util.concurrent.atomic</code>包中提供了大量原子变量类，原子类底层采用CAS（Compare-and-Swap）方式。CAS在竞争失败时会再试而基于锁保护的操作在获取锁失败时线程将会被挂起，在竞争不激烈环境下失败重试能避免线程挂起而获得不错的性能，在竞争激烈时CAS操作会频繁失败重试。</p>
<p>CAS：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS 的典型使用模式是：首先从 V 中读取值 A ，并根据 A 计算新值 B ，</span></span><br><span class="line"><span class="comment"> * 然后再通过 CAS 以原子方式将 V 中的值由 A 变成 B （只要在这期间没有任何线程将 V 的值修改为其他值）。</span></span><br><span class="line"><span class="comment"> * 由于 CAS 能检测到来自其他线程的干扰，因此即使不使用锁也能够实现原子的读一改一写操作序列。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CAS</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CAS</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较成功则换值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 对于 i = 1; i = i + 1</span></span><br><span class="line"><span class="comment">     * 我们的预期是1，操作后应该结果是2；</span></span><br><span class="line"><span class="comment">     * 如果此时i确实是1，那就说明没人修改，那就直接将预期结果2赋值给它。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expectedValue 期望值，即我们看到的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue      新值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title function_">compareAndSwap</span><span class="params">(T expectedValue, T newValue)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">        <span class="keyword">if</span> (value == expectedValue)</span><br><span class="line">            value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #compareAndSwap(int, int)&#125; 返回的是旧值，也就是我们期望的那个值的。</span></span><br><span class="line"><span class="comment">     * &lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 如果它的返回值和我们的期望值一样，说明此时交换成功了。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expectedValue 期望值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue      新值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(T expectedValue, T newValue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (expectedValue == compareAndSwap(expectedValue, newValue));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CASCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CAS&lt;Integer&gt; value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CASCounter</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = <span class="keyword">new</span> <span class="title class_">CAS</span>&lt;&gt;(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            v = value.get();</span><br><span class="line">            <span class="comment">// 相等表示替换成功，失败则重试</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (v == value.compareAndSwap(v, v + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> v + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul>
<li><p>ThreadPoolExecutor</p>
<ul>
<li>corePoolSize 初始线程池大小</li>
<li>maximumPoolSize 最大线程池大小</li>
<li>keepAliveTime 不活动线程存活时间</li>
<li>workQueue 任务缓冲队列</li>
<li>threadFactory 创建工作线程的工厂，特殊情况下我们需要定制我们的工作线程。</li>
</ul>
<p>  工作线程满了后新任务可以放到队列中，队列分为有界队列和无界。使用无界队列在工作线程处理不及时时可能会出现排队任务太多，内存溢出情况。</p>
<p>  使用有界队列时，如果队列满了以后有不同的<code>饱和策略</code>来处理。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line"><span class="comment">// 饱和策略</span></span><br><span class="line"><span class="comment">//executorService.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy());</span></span><br><span class="line"><span class="comment">//executorService.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardOldestPolicy());</span></span><br><span class="line"><span class="comment">//executorService.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());</span></span><br><span class="line">executorService.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">task</span> <span class="operator">=</span> i;</span><br><span class="line">    System.out.printf(<span class="string">&quot;put task %d\n&quot;</span>, task);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.printf(<span class="string">&quot;run task: %d; thread: %s \n&quot;</span>, task, Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(e.getClass());</span><br><span class="line">        System.out.printf(<span class="string">&quot;put fail %d [%s]\n&quot;</span>, task, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>newFixedThreadPool</p>
<p>  大小固定的线程池。注意<code>LinkedBlockingQueue</code>是无界的。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>newCachedThreadPool    </p>
<p>  可缓存的线程池，会回收空闲的线程。注意：这种方式创建的线程池<code>maximumPoolSize</code>为<code>Integer.MAX_VALUE</code>。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>newSingleThreadExecutor   </p>
<p>  创建一个单线程线程</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>newScheduledThreadPool   </p>
<p>  创建一个可定时及周期性任务执行任务的线程池。注意：线程池大小为<code>Integer.MAX_VALUE</code>。</p>
</li>
<li><p>newWorkStealingPool </p>
<p>  这个线程池是1.8引入的。该线程池使用<code>ForkJoinPool</code>实现，参数<code>parallelism</code>为线程的并行数量其继承自<code>AbstractExecutorService</code>。<code>ForkJoinPool</code>实现了一个<code>工作窃取</code>算法，使得空闲线程能够窃取别的线程分解出来的子任务，从而让所有的线程都尽可能处于满负荷，提高执行效率。有一个无参数版本，其将<code>parallelism</code>设为<code>Runtime.getRuntime().availableProcessors()</code>,即处理器核数。</p>
</li>
<li><p>ForkJoinPool</p>
<p>  TODO</p>
</li>
</ul>
<h4 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h4><ul>
<li><p>Abort </p>
<p>  默认策略直接拒绝新任务，抛出<code>RejectedExecutionException</code>异常。</p>
</li>
<li><p>Discard</p>
<p>  悄悄的丢弃最新的任务，不会有任何异常抛出。</p>
</li>
<li><p>DiscardOld </p>
<p>  同<code>Discard</code>恰恰相反，悄悄的抛弃最旧的待执行任务。</p>
</li>
<li><p>CallerRuns</p>
<p>  及不抛弃，也不会抛异常。线程池和队列都满时会在调用了<code>execute</code>的线程中执行，这种情况主线程可能会被阻塞。</p>
</li>
</ul>
<h4 id="线程池停止"><a href="#线程池停止" class="headerlink" title="线程池停止"></a>线程池停止</h4><ul>
<li><p>shutdown </p>
<p>  非阻塞方法。停止线程，会等待所有工作及排队线程都执行完毕。</p>
</li>
<li><p>shutdownNow</p>
<p>  非阻塞。先停止（<code>interrupt</code>）正在执行的线程，然后返回正在等待的任务。通过检测<code>Thread.currentThread().isInterrupted()</code>适时结束正在执行的线程。</p>
</li>
<li><p>awaitTermination(timeout, unit)</p>
<p>  阻塞等待最长<code>timeout</code>等待线程池结束。</p>
</li>
</ul>
<h3 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h3><p>在有些问题中，如果可用资源越多那么解决问题的速度就越快。可用资源与速度是一个什么关系呢？我们增加了10倍机器能获得性几倍的提升呢？Amdahl定律描述的正是这个问题。</p>
<p>在增加计算资源的情况下，程序理论上能实现的最高加速比，这个值取决于程序中科并行组件与串行组件所占的比重。假设F是必须被串行执行的部分，那么根据Amdahl定律，在包含N个处理器的机器中，最高的加速比为：<br><img src="/images/amdahl.png"><br>当N趋近无穷大时，最大的加速比趋近1&#x2F;F。因此如果程序中如果有50%的计算需要串行执行，那么最高的加速比只能是2（不管有多少个处理器多少个线程可用）。如果程序中有10%的计算需要串行，那么最高的加速比将接近10。</p>
<p>Amdahl定律的应用场景：</p>
<p>在一个订单处理系统中，我们应用服务器可以很方便的扩展很多倍。那么在数据库中并发扣减库存这个点就是整个系统的串行点，这个点直接决定了整个系统最终的吞吐量。遇到这种问题，我们盲目堆机器初期能提高吞吐量，增加到一定程度性能将不再提升，而且还会因为线程竞争激烈造成性能下降。</p>
<h3 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h3><ul>
<li><p>java.util.ConcurrentModificationException</p>
<p>  对容器迭代的时候如果同时对其进行修就会抛出<code>ConcurrentModificationException</code>。这类似一种<strong>预警机制</strong>，它将计数器与容器变化关联。如果迭代期间计数器被修改那么<code>hasNext</code>或者<code>next</code>将抛出异常。在迭代期间迭代器可能并没有意识到容器已经修改了，这是一种权衡机制来尽量避免并发修改操作对程序的影响。</p>
<p>  <code>modCount</code>是List的一个成员变量，表示容器修改(add&#x2F;remove)次数。<br>  <code>expectedModCount</code>是<code>Iterator</code>内部变量，这个值的初始值就是<code>modCount</code>的值。如果迭代过程中修改了容器，<code>modCount</code>就会改变，而此时<code>expectedModCount</code>还是<code>modCount</code>的旧值。    </p>
<blockquote>
<p>不管是简单的for，还是增强for循环编译后都是Iterator迭代。<br>直接调用<code>Iterator.remove</code>来删除元素不会出现<code>ConcurrentModificationException</code>异常，其方法内部会重新修正<code>modCount</code>和<code>expectedModCount</code>的值。</p>
</blockquote>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* An optimized version of AbstractList.Itr</span></span><br><span class="line"><span class="comment">* 内部类，可以直接访问宿主类属性。用于容器迭代。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="comment">// 保留原始的modCount值，可以看做是oldModCount</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 每次迭代是都检查 </span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 直接调用it.remove()后不会触发ConcurrentModificationException异常</span></span><br><span class="line">            <span class="comment">// 这里会重置expectedModCount的值</span></span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; consumer)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(consumer);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> ArrayList.<span class="built_in">this</span>.size;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">            consumer.accept((E) elementData[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">        cursor = i;</span><br><span class="line">        lastRet = i - <span class="number">1</span>;</span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// modCount 为宿主类属性，实时的</span></span><br><span class="line">        <span class="comment">// expectedModCount 为创建迭代器时的 modCount</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果这里没有即时抛出`ConcurrentModificationException`异常，</span></span><br><span class="line"><span class="comment">// 因为我们在循环开始前已经取过size值，那么后面肯定会因为删除元素抛出`ArrayIndexOutOfBoundsException`异常。</span></span><br><span class="line"><span class="comment">// 这种机制被称为及时失败（fail-fast），及早发现问题抛出问题避免无意义的操作，因为最终迭代过程可能出现异常。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;pill&quot;</span>.equals(strs.get(i))) strs.remove(strs.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  解决方法使用<code>CopyOnWriteArrayList</code>替代<code>ArrayList</code>。</p>
</li>
<li><p>java.lang.UnsupportedOperationException</p>
<p>  容器逸出时，为了避免容器被修改可以使用<code>Collections.unmodifiable(Map|List)</code>等静态方法包装容器来保护原始容器不被修改。</p>
<p>  调用这些容器的修改操作(add&#x2F;remove)时会抛出UnsupportedOperationException异常。</p>
<p>  另外：<code>Arrays.asList</code>方法返回的是一个<code>fixed-size</code>list，我们调用它的修改成操作时也会抛出<code>UnsupportedOperationException</code>异常。对其重新封装<code>new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</code>后就不会出现此问题。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strs = Collections.unmodifiableList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)));</span><br><span class="line">strs.remove(<span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>java.lang.IllegalMonitorStateException</p>
<p>  这在我们调用对象的<code>wait</code>或者<code>notify/notifyAll</code>时会抛出，主要原因是我们没有获取被被调用对象的锁。</p>
<p>  错误示例：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">lock.wait(); </span><br><span class="line">doSomething();</span><br><span class="line">lock.notifyAll();</span><br></pre></td></tr></table></figure>

<p>  正确示例：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    lock.wait();</span><br><span class="line">    doSomething()</span><br><span class="line">    lock.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://book.douban.com/subject/10484692/">Java并发编程实战</a></li>
</ul>

  </div>
  <div class="article-license">
    <!-- 
    <a rel="license" style="text-decoration: none;" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
        <img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" />
    </a>
    <br/> 
    -->
    本站采用「<a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">署名 4.0 国际</a>」进行许可。
</div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/search/">搜索</a></li>
         
          <li><a href="/atom.xml">RSS</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">1.1.</span> <span class="toc-text">内存屏障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E4%B8%8Evolatile"><span class="toc-number">1.2.</span> <span class="toc-text">synchronized与volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">1.3.</span> <span class="toc-text">并发与同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.</span> <span class="toc-text">并发编程中的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.5.1.</span> <span class="toc-text">线程状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD"><span class="toc-number">1.5.2.</span> <span class="toc-text">线程中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%B8%AD%E6%96%AD%E4%BB%BB%E5%8A%A1%EF%BC%9F"><span class="toc-number">1.5.3.</span> <span class="toc-text">如何中断任务？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shutdown-Hook"><span class="toc-number">1.5.4.</span> <span class="toc-text">Shutdown Hook</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97"><span class="toc-number">1.5.5.</span> <span class="toc-text">内置条件队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7"><span class="toc-number">1.6.</span> <span class="toc-text">同步工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">同步容器 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">并发容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">1.6.3.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.6.4.</span> <span class="toc-text">同步工具类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">1.7.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F"><span class="toc-number">1.7.1.</span> <span class="toc-text">原子变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.8.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5"><span class="toc-number">1.8.1.</span> <span class="toc-text">饱和策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%81%9C%E6%AD%A2"><span class="toc-number">1.8.2.</span> <span class="toc-text">线程池停止</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Amdahl%E5%AE%9A%E5%BE%8B"><span class="toc-number">1.9.</span> <span class="toc-text">Amdahl定律</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="toc-number">1.10.</span> <span class="toc-text">常见异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.11.</span> <span class="toc-text">参考</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="mailto:?subject=Java并发&body=Check out this article: https://kekek.cc/post/java.util.concurrent.html"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://kekek.cc/post/java.util.concurrent.html&title=Java并发"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2026 <span class="heart"></span> tyk <a href="https://beian.miit.gov.cn" target="_blank">京ICP备17056993号-1</a>
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/search/">搜索</a></li>
         
          <li><a href="/atom.xml">RSS</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<!-- 
<link rel="stylesheet" href="/lib/font-awesome/css/fontawesome-all.min.css">
 -->
<!-- 
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">
 -->
<link href="//lib.baomitu.com/font-awesome/5.0.8/web-fonts-with-css/css/fontawesome-all.min.css" rel="stylesheet">
<link href="//lib.baomitu.com/justifiedGallery/3.6.5/css/justifiedGallery.min.css" rel="stylesheet">

<!-- jquery -->
<!-- 
<script src="/lib/jquery/jquery.min.js"></script>
 -->
<!-- 
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
 -->
<script src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script>
<script src="//lib.baomitu.com/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>

<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-110681544-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

    <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?eb3776b1457fd82ea128e578d4ca32a7";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'keke-site';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


